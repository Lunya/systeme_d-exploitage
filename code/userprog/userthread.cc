#include "userthread.h"
#include "thread.h"
#include "system.h"
#include "addrspace.h"
#include "synch.h"

static void StartUserThread(void *schmurtz)
{
	DEBUG('s', "Debut StartUserThread\n");
	//currentThread->space->InitRegisters();
	// Initial program counter -- must be location of "Start"
	//Schmurtz * s = (Schmurtz)schmurtz;
    machine->WriteRegister (PCReg, ((Schmurtz *)schmurtz)->f);
    machine->WriteRegister (4, ((Schmurtz *)schmurtz)->arg);

    // Need to also tell MIPS where next instruction is, because
    // of branch delay possibility
    machine->WriteRegister (NextPCReg, machine->ReadRegister(PCReg) + 4);
	machine->WriteRegister (31, ((Schmurtz *)schmurtz)->fexit);
    // Set the stack register to the end of the address space, where we
    // allocated the stack; but subtract off a bit, to make sure we don't
    // accidentally reference off the end!
    machine->WriteRegister (StackReg, currentThread->space->AllocateUserStack());

	delete schmurtz;
	DEBUG('s', "Fin StartUserThread\n");
	machine->Run();
}

void StartKernelThread(void * tmp)
{
	DEBUG('s', "Debut StartUserThread\n");
	currentThread->space->InitRegisters ();	// set the initial register values
	currentThread->space->RestoreState ();	// load page table register
	DEBUG('s', "Fin StartUserThread\n");
	machine->Run();
}
//*Tmp

/*
// For testing purposes, we initialized some names to recognize our
// threads.
char names[][10] = {"Jojo", "Bernard", "Georges", "Patrick", "Manuel"};
int i=0;
*/
int do_ThreadCreate(int f, int arg, int fexit)
{

	DEBUG('s', "Debut do_ThreadCreate\n");
	/*
	// For testing purposes, we named each threads with a name 
	// in the array upside the function.
	Thread * newThread = new Thread(names[i]);
	i++;
	*/
	Thread * newThread = new Thread("new thread");
	Schmurtz * schmurtz = new Schmurtz;

	schmurtz->f = f;
	schmurtz->arg = arg;
	schmurtz->fexit = fexit;
	newThread->Start(StartUserThread, schmurtz);
	DEBUG('s', "Fin do_ThreadCreate\n");
}

void do_ThreadExit()
{
	DEBUG('s', "Debut do_ThreadExit %s \n", currentThread->getName());
	currentThread->space->threadCounter --;

	DEBUG('s', "threadCounter : %d \n", currentThread->space->threadCounter);
	if (!currentThread->space->threadCounter)
	{
		DEBUG('s', "Il n'y a plus de threads dans cet espace d'adressage.\n");
		DEBUG('s', "Nombre de processus : %d \n", processCounter);
		processCounter--;
		if (processCounter == 0)
		{
			interrupt->Halt();
		}
		else
		{
			//delete currentThread->space;
			currentThread->Finish();
		}
	}
	else
	{
		DEBUG('s', "Current Thread Position : %d \n", currentThread->stackPosition);
		//La vÃ©rification du -1 permet de savoir si on est pas le thread 
		// principal, qui lui n'a pas de position dans cette bitmap
		if (currentThread->stackPosition != -1)
		{
			currentThread->space->bitmap->Clear(currentThread->stackPosition);
			currentThread->space->spaceAvail->V();
		}
		currentThread->Finish();
	}
}